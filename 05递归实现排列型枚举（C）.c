#include <stdio.h>

/*
题目：
从1-n这n个整数排成一排并打乱次序，
按字典序输出所有可能的选择方案。
*/

/*
这段C代码实现了一个全排列生成器，用于找出从1到n的所有可能的排列组合。

1. **全局变量定义**:
   - `arr[10]`: 用于存储一个排列结果，这里假设排列的元素个数不会超过10。
   - `vis[10]`: 访问标记数组，用于记录数字是否已经被使用。初始化为0，表示所有数字都未被使用。

2. **函数`print_one_result(int n)`**:
   - 这个函数用于打印一个排列结果。它接受排列的元素个数`n`作为参数，遍历`arr`数组并打印其中的元素，元素间用空格分隔。

3. **函数`f(int i, int n)`**:
   - 这是一个递归函数，用于生成全排列。
   - 参数`i`表示当前正在处理的排列位置。
   - 当`i == n`时，说明一个完整的排列已经生成，此时调用`print_one_result(n)`打印这个排列。
   - 通过一个`for`循环从1到n遍历可能的数字，使用`vis`数组检查数字是否已经被使用过。
   - 如果数字k未被使用（`vis[k] == 0`），则：
     - 将数字k放入当前排列的第i个位置：`arr[i] = k`。
     - 标记数字k已经被使用：`vis[k] = 1`。
     - 递归调用`f(i + 1, n)`以生成下一位置的排列。
     - 递归返回后，重置`vis[k] = 0`，这个动作称为回溯，以确保k在下一次循环中可以再次被使用。

4. **`main()`函数**:
   - 读取用户输入的整数n。
   - 调用`f(0, n)`开始生成从1到n的全排列。

综上所述，这段代码通过递归和回溯算法生成并打印出所有从1到n的全排列组合。
*/

int arr[10], vis[10] = {0}; // 定义数组arr用于存储结果，数组vis用于标记数字是否已被使用

// 打印一个结果的函数
void print_one_result(int n) {
    for(int i = 0; i < n; i++) {
        if(i) {
            printf(" "); // 如果不是第一个数字，先打印一个空格
        }
        
        printf("%d", arr[i]); // 打印当前位置的数字
    }
    printf("\n"); // 换行
    
    return ;
}

// 递归函数，用于生成排列组合
void f(int i, int n) {
    if(i == n){ // 如果已经填充到最后一个位置，则打印结果
         print_one_result(n);
    }
    for(int k = 1; k <= n; k++){ // 遍历所有可能的数字
        	if(vis[k]){ // 如果该数字已经被使用过，跳过
            	continue;
         }
            
        arr[i] = k; // 将当前数字放入数组对应位置
        vis[k] = 1; // 标记该数字已被使用
            
        f(i + 1, n); // 继续填充下一个位置
            
        vis[k] = 0; // 回溯，将该数字标记为未使用
        }
}

int main() {
    int n;
    
    scanf("%d", &n); // 输入需要排列的数字个数
    
    f(0, n); // 从第一个位置开始生成排列组合
    
    return 0;
}
